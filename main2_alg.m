clear
clearvars
% close all
clc 

global nCk  nx 
global Ck
% Ck =4;
tic
%% %%%%%%%%% Cluster's size & number of clusters %%%%%%%%%

nx=2;                   % Agent's dimensions
% When the clusters have different number of agents
nCk = [120 140 170 200];
m = length(nCk);
n = sum(nCk);
nk = nCk(Ck);

%% State and Input Matrices
theta = 30; 
a =1*[cos(theta),-sin(theta);sin(theta),cos(theta)]; %dynamics of each agent in the network
b2=[1;1];     % input matrix. 

controllability_check(a,b2) % Checks if the systems is controllable or not.


%% data load

%Generates the initial conditions that satisfies the clustered network
%condition.

% init =  initial_conditions(nCk); 
load ('Data_02_12_2021/initial_conditions.mat')


%%  Random Laplacian Graph Generated by the Erdos-Renyi Algorithm
% p = 0.05; % probablity
% Internal and External Laplacian of the Graph
% [Lint,  Lext] = laplacianER(nCk, p, 2);
% tot_Ext_con = sum(diag(Lext))/2

load ('Data_02_12_2021/Lext.mat')
load ('Data_02_12_2021/Lint_complete.mat')

%% Generate the connected internal graph
% [L_con, L_norm] =  conn_int_graph(Lint, nCk);
% Lint = L_con;
% load ('Data-30-09-2021/Lint_connected.mat')

%% Laplacian of the Network
L = Lint + Lext;        

%% Weighted Laplacian used during the external control design
[Lextbar,  H, W] = weighted_laplacian(nCk, Lext);


%% Weight Matrix Rk
Rk = [1/nCk(1), 1/nCk(2), 1/nCk(3), 1/nCk(4)];


%% Generate Internal and External Gain.
[Kint, Kext] = initial_gain(nCk, a, b2, Lextbar, Rk);


[~, Kext1] = initial_gain(nCk, a, b2, L, Rk); % Gain using Jihene's Algorithm

load ('Data_02_12_2021/Kext_opt_complete.mat')
load ('Data_02_12_2021/Kint_opt_complete.mat')

%% Cost Bound
% Threshold for the cost. 
sigma =0.8;            


%% Sub-Optimal Gain Generated by Algorithm
% [Kext_opt] = suboptimal_gain_generation_algorithm(nCk,a, b2, Lext, init, Kext, Rk, sigma);

%% Initial Settings
delta_t = 0.01;
tf=12;
tspan = 0:delta_t:tf;

%% Gain Input
Kext_A = 1*Kext_opt;
Kint_A  = 1*Kint;
% 
% Kext_A = Kext1;
% Kint_A = Kext1;

%% org dyn
[t, x, x_1, x_2, x_1_err, x_2_err]= network_dynamics (nCk,  a, b2, Lint, Lext, Kext_A, Kint_A, init, tspan);

% % Error plot
figure 
% subplot(2,1,1)
plot(t, x_1_err, 'LineWidth',1.1)
xlabel('Time (s)', 'Interpreter','latex')
ylabel('Component 1', 'Interpreter','latex')
title('Synchronization State Error with Graph $\mathcal{G}_{1}$', 'Interpreter','latex')
grid on 
grid minor
% subplot(2,1,2)
% plot(t, x_1_err, 'LineWidth',1.1)
% xlabel('Time (s)', 'Interpreter','latex')
% ylabel('Component 1', 'Interpreter','latex')
% grid on 
% grid minor






%% External/ Average Error Dynamics
C1 = 1; C2 =2 ; C3 = 3; C4 = 4;
 [t_avg1, Y_k_1, A_k_1,  J_avg_inst_1] = average_error_dynamics  (nCk, a, b2, C1, Kext_A, Lext,  Rk, init, tspan, delta_t); 
 [t_avg2, Y_k_2, A_k_2,  J_avg_inst_2] = average_error_dynamics  (nCk, a, b2, C2, Kext_A, Lext,  Rk, init, tspan, delta_t);
 [t_avg3, Y_k_3, A_k_3,  J_avg_inst_3] = average_error_dynamics  (nCk, a, b2, C3, Kext_A, Lext,  Rk, init, tspan, delta_t);
 [t_avg4, Y_k_4, A_k_4,  J_avg_inst_4] = average_error_dynamics  (nCk, a, b2, C4, Kext_A, Lext,  Rk, init, tspan, delta_t);

 
%% Overall Network Dynamics
[J_org_inst_1] = original_cost(nCk, C1, Lint, Lext, x, Kext_A, Kint_A, Rk, delta_t );
[J_org_inst_2] = original_cost(nCk, C2, Lint, Lext, x, Kext_A, Kint_A, Rk, delta_t );
[J_org_inst_3] = original_cost(nCk, C3, Lint, Lext, x, Kext_A, Kint_A, Rk, delta_t );
[J_org_inst_4] = original_cost(nCk, C4, Lint, Lext, x, Kext_A, Kint_A, Rk, delta_t );



%% Epsilon
a1 = norm(b2,2)*norm(Kext_A,2)*norm(Lext,2);
Kint_opt_norm = [];
for i = 1:length(Kint_A)
    Kint_opt_norm_i = norm(Kint_A(i),2);
    Kint_opt_norm = [Kint_opt_norm; Kint_opt_norm_i];
end
a3 = norm(b2,2)*min(Kint_opt_norm)*min(nCk);
epsilon = a1/a3
tot_con_ext  = sum(diag(Lext))/2


[ J_total] = total_cost1( J_org_inst_1, J_org_inst_2, J_org_inst_3, J_org_inst_4);

%% Plot form T to infinity1
T = 2;
for i = 1:length(t)
    if  t(i) == T
        index_T  = i;
    end
end
tT = t(index_T:end,:);

[J_avg_1, J_avg_2, J_avg_3, J_avg_4, J_tot_1, J_tot_2, J_tot_3, J_tot_4, J_tot, J_avg, delta_J, delta_J_per ] = total_avg_cost( nCk, J_avg_inst_1, J_avg_inst_2, J_avg_inst_3, J_avg_inst_4, J_org_inst_1, J_org_inst_2, J_org_inst_3, J_org_inst_4, index_T);

%% Plots
figure ('Name','Cost T to infinity')
plot(tT, J_tot_1, 'LineWidth',1.3, 'color', 'green')
hold on 
plot(tT, J_avg_1,'--', 'LineWidth',1.3, 'color', 'black')
xlabel('Time(s)', 'Interpreter','latex')
title(['Cluster 1 Cost from (T = ',num2str(T),') to infinity'],  'Interpreter','latex')
legend('Cluster  Cost','External Cost','Location','southeast', 'Interpreter','latex')
grid  on
grid minor


